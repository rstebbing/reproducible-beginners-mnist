from itertools import islice

import numpy as np
from sklearn.utils.validation import check_X_y, check_random_state


class SimpleBatchFeeder(object):
    """A simple batch "feeder" that outputs collections of rows of `X` and `y`.

    The number of rows is specified by `batch_size` (default all
    rows). Importantly, the sequence of batches is *completely* determined by
    `batch_size`, `start`, and `seed`."""
    def __init__(self, X, y, dtype=np.float32,
                 batch_size=None, start=0, seed=None):
        self.X, self.y = check_X_y(X, y, dtype=dtype, multi_output=True)
        num_rows, _ = self.X.shape

        if batch_size is None:
            batch_size = num_rows
        if batch_size <= 0:
            raise ValueError('batch_size <= 0 (= {})'.format(batch_size))
        self.batch_size = batch_size

        # Initialize the indices iterator (skipping the first `start` items).
        random_state = check_random_state(seed)
        i = enumerate(_infinite_shuffled_indices(num_rows, random_state))
        if start < 0:
            raise ValueError('start <= 0 (= {})'.format(start))
        self._i = islice(i, start, None)

    def next_batch(self):
        # Take the next `batch_size` row indices from the (infinite) iterator
        # `_i`.
        batch = list(islice(self._i, self.batch_size))

        # `i` (below) is the index of the last row index in the `batch` ...
        assert batch
        i, _ = batch[-1]
        # ... and `next_start` is the value such that if another instance of
        # `BatchFeeder` was constructed with identical `X`, `y`, `batch_size`,
        # and `seed`, using `start=next_start` would guarantee that the new
        # `BatchFeeder` and *this* instance would yield identical batches from
        # this point on.
        next_start = i + 1

        row_indices = [r for _, r in batch]

        return next_start, (self.X[row_indices], self.y[row_indices])


def _infinite_shuffled_indices(n, random_state):
    """A generator that repeatedly yields integers in the half-open interval
    `[0, n)`, where integers are repeated in a sequence of "epochs". The
    (infinite) sequence generated by this generator is entirely determined by
    the initial state of `random_state`."""
    indices = np.arange(n)
    while True:
        random_state.shuffle(indices)
        for i in indices:
            yield i
